# java内存管理

## 对象是否可回收

垃圾回收首先要解决的问题是需要判断哪些对象可以回收，常用的方法有：引用计数法和可达性分析

* 引用计数
  * 就是将一个对象被其他对象应用的情况记录下来，不如对象A被B和C引用了，那么A被引用的数就是2，如果为零就可以被回收了。缺点是无法处理相互应用的情况。
* 可达性分析
  * 从一些根节点开始遍历，看将被引用的对象标记下，然后没有被标记到的对象就可以被回收了。
  * 这些根节点叫 GC roots。
  * GC roots 有
    * 虚拟机栈
    * 本地方法栈
    * 方法区静态属性引用的对象
    * 方法区常量引用的对象

## 引用类型

* 强引用 
一句话总结 “强软-弱换, **软弱** 的顺序容易记乱，记住软弱这个词，软在前面所以比弱更坚挺一些“
  * java代码中正常的引用都是强引用
* 软引用
  * 在内存垃圾回收之前回都会被保留，内存不足时如一个对象没有被强引用持有则对象会被回收。
* 弱引用
  * 在垃圾回收时如果一个对象没有被强引用或弱引用持有，则对象被回收，和上面弱引用不同的是不管内存够不够都会被回收，弱引用只在内存不足时才触发回收。
* 幻引用
  * 一出生即死亡，没法冲虚引用获得虚引用指向的对象。

## 垃圾回收涉及到的算法

* 标记清除算法
  * 优点：简单
  * 缺点：不是很高效、会产生内存碎片
* 复制算法
  * 优点 内存整齐，主流都采样这种方式
  * 内存划分为Eden和两个Survivor区 8：1：1的比例，
* 标记整理算法
  * 主要用于老年代的回收中，因为老年代的存活对象较多，复制算法效率较低
* 分代收集算法
  * 说的就是将堆区进行老年代，新生代的划分，然后在不同的代采用不同的收集算法

## 集中垃圾收集器

* 目前垃圾回收都会发生STW（Stop The World）的情况，也就是停止用户线程的运行。

## Serial

适用于新生代和老年代（Serial Old）

* 新生代使用复制算法
* 老年代使用标记整理算法
* 单线程

## Serial Old

* Serial的老年版本

## ParNew

**Serial** 的多线程版本

* 多线程并行收集在多核情况下更高效

## Parallel Scavenge

吞吐量优先的收集器，有控制吞吐量的参数，更加注重运行垃圾回收的CPU占用时间和运行用户程序CPU时间之间的分配比例。

## Parallel Old

Parallel Old的老年代收集版本

## CMS

Concurrent Mark Sweep —— 从名字就可以看出 1.并发，2.标记清除
垃圾收集过程4个阶段

1. 初始标记 会发生STW
2. 并发标记 并行不会停止用户线程
3. 重新标记 会发生STW
4. 并发清除

特点：

* 老年代收集器
* 并发收集
* 低延迟
* CPU资源敏感
* 无法处理浮动垃圾
* 标记—清除导致的内存碎片化

## G1收集器

也有分代概念，但是G1既可以处理新生代也能处理老年代，采用标记整理算法。
进内存划分出区域
G1的四个阶段和CMS类似

1. 初始标记 会发生STW
2. 并发标记
3. 最终标记 会发生STW
4. 筛选回收 会发生STW

## 对象内存分配的一些策略

* 对象一般在新生代分配
* 大对象可直接进入老年代
* 存活一定周期的对象进入老年代
* 空间分配担保
